https://www.youtube.com/watch?v=TPVH_coGAQs&list=PLk6CEY9XxSIAeK-EAh3hB4fgNvYkYmghp

как создать thread in c++


std::thread t1(); // threads нужен вызываемый объект 
// три способа создать вызываемый объект

1. Pointer to function ->
	void someFunction(int someArgs) {
	// Function code here
	}
	std::thread t1(someFunction, someArgs); // here we create thread and run someFunction in this thread
	t1.join(); // the threas in witch we create t1 will wait until t1 finish its work

	void someFunction(int& someArgs) {
	// Function code here
	}
	// To pass smth by reference we need to use std::ref
	std::thread t1(someFunction, std::ref(someArgs));
	Зачем и почему
	void fun(int& param) {
		param += 10;
	}

	int main() {
		int x = 5;
		std::thread t(fun, x);  
	}
	Все аргументы копируются в память потока
	Ссылка также копируется
	Поток сделает временный int, далее копирует x в него и передает 
	ссылку на временный int в функцию fun

	Компилятор развернет во что-то такое
	void thread_function(void* data) {
		int copied_x = *static_cast<int*>(data);  
	    fun(copied_x); 
	}

	int main() {
	    int x = 5;
	    int copy_for_thread = x;  // Копия!
	    start_thread(thread_function, &copy_for_thread);
	}

	С указателем кстати бы сработало
	
	void fun(int* x) {
		*x += 10;
	}
	
	int main(int argc, char* argv[]) {
	
		int x = 5;
		int* p = &x;
		std::thread t(fun, p);
		t.join();
		std::cout << "x = " << x << std::endl; // x should be 15
	}
	
	std::ref создает std::reference_wrapper<T> - специальную обертку, которая:
	Может копироваться (как требует std::thread)
	Неявно преобразуется к ссылке на оригинальный объект
	Сохраняет семантику ссылки при использовании
	template<typename T>
	class reference_wrapper {
	private:
	    T* ptr;  // Храним указатель!
	    
	public:
	    // Конструктор - принимает ссылку, сохраняем указатель
	    reference_wrapper(T& ref) : ptr(&ref) {}
	    
	    // Неявное преобразование обратно к ссылке
	    operator T&() const { return *ptr; }
	    
	    // Явное получение ссылки
	    T& get() const { return *ptr; }
	    
	    // Перегрузка оператора вызова функции
	    template<typename... Args>
	    auto operator()(Args&&... args) const 
	        -> decltype(std::invoke(get(), std::forward<Args>(args)...)) {
	        return std::invoke(get(), std::forward<Args>(args)...);
	    }
	};
	template<typename T>
	reference_wrapper<T> ref(T& t) noexcept {
	    return reference_wrapper<T>(t);
	}
	void print(int& ref) {
    std::cout << ref;
	}
	
	print(rw);  // Магия! Неявное преобразование:
	// rw.operator int&() вызывается, возвращает *ptr
	// print получает int& на оригинальный x
	Что такое std::bind?
	Это способ создать новую функцию, "привязав" (bind) 
	часть аргументов существующей функции к конкретным значениям.
	А вызвать позже

2. Labmda function

	auto fun = [](int someArgs) {
	// Function code here
	} ;
	std::thread t1(fun, someArgs);

3. Functors
	class Functor {
	public:
		void operator()(int someArgs) {
			// Function code here
		}
	};
	Functor functor;
	std::thread t1(functor, someArgs);

4. Non-static member function
	class MyClass {
	public:
		void memberFunction(int someArgs) {
			// Function code here
		}
	};
	MyClass obj;
	std::thread t1(&MyClass::memberFunction, &obj, someArgs); // first arg is pointer to member function, second is pointer to object

5. Static member function
	class MyClass {
	public:
		static void staticMemberFunction(int someArgs) {
			// Function code here
		}
	};
	std::thread t1(&MyClass::staticMemberFunction, someArgs); // like normal function pointer

Join Detach Joinable
	если мы вызвали join мы будем ждать пока поток завершится там где мы взывали join!
	два раза вызвать join нельзя - будет ошибка
	нужно писать joinable для этого 
	если мы вызвали detach поток отделяется от основного потока и работает сам по себе

Mutex and Race Condition
	Когда несколько потоков обращаются к одним и тем же данным одновременно, 
	может возникнуть

	Race Condition
	int myAccount = 0;
	
	void addMoney(){
		++myAccount;
	}
	
	int main(){
		std::thread t1(addMoney);
		std::thread t2(addMoney);
		t1.join();
		t2.join();
		std::cout << myAccount << std::endl; // expected 2 but can
	}
	Fix using Mutex
	std::mutex mtx;
		void addMoney() {
			mtx.lock();
			++myAccount;
			mtx.unlock();
		}

	mutex.try_lock() 
	if(try_lock){
		// critical section
	} else {
		// could not get the lock
	})

	void safe_operation() {
    while (true) {
        if (mtx1.try_lock()) {
            if (mtx2.try_lock()) {
                // Оба мьютекса захвачены
                std::cout << "Critical section executed\n";
                mtx2.unlock();
                mtx1.unlock();
                break;
            } else {
                // Не удалось захватить mtx2 - освобождаем mtx1
                mtx1.unlock();
                std::this_thread::yield(); // Даем шанс другим потокам
            }
		}
		}
	}
	There is also std::try_lock(mtx1, mtx2, ...);
	int result = std::try_lock(m1, m2, m3);

	if (result == -1) {
	    // Все мьютексы захвачены успешно
	} else {
	    // Мьютекс под индексом 'result' не удалось захватить
	    // Все уже захваченные мьютексы автоматически освобождаются!
	}
	ЗАЧЕМ
	// ПЛОХО: Риск deadlock!
	void transfer(Account& a, Account& b, int amount) {
	    std::lock_guard<std::mutex> lock1(a.mtx);  // Захватили A
	    std::lock_guard<std::mutex> lock2(b.mtx);  // Захватили B
	    // ... операция перевода
	}
	
	// Если в другом потоке:
	// std::lock_guard<std::mutex> lock1(b.mtx);  // Сначала B
	// std::lock_guard<std::mutex> lock2(a.mtx);  // Потом A
	// DEADLOCK!

	RAII version of mutex is std::lock_guard
		void addMoney() {
			std::mutex mtx;
			std::lock_guard<std::mutex> lock(mtx); // lock acquired here
			++myAccount;
		} // lock released here when lock goes out of scope
	unique_lock more 

	Deadlock

	